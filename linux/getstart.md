# 预备知识

## 1.1 内核简介

### 传统操作系统

传统操作系统其内核具有多方面的功能，既包含用于管理属于应用层的"进程"的模块，如进程管理，也包含为这些进程提供各种服务的模块，如进程间通信，设备驱动和文件系统等等。

### 微内核

内核中提供各种服务的模块与使用这些服务的进程之间的进程之间形成了一种"Client/Server"的关系。

把服务提供者从内核中拿出，并设计成"服务进程"，其中必须留着内核中的模块只有进程间通信。内核本身的体积可以裁剪到很低。

服务进程放到内核之外，可以单独的设计，实现以及调试，可以按实际需求来配置和启动。基于这样的想法，便形成了"微内核"（Micro-Kernel）。

对于实时系统和嵌入式系统，通常这些系统存储空间有限，整个系统都必须放在EPROM中，需求又单一，所以实时系统和嵌入式系统都采用微内核。

但是这些服务都放在进程层次上，再通过进程间通信（通常是报文传递）提供服务，增加了系统运行开销，降低了效率。

### 宏内核

通用式系统由于所需的服务量大，一体化内核更适合。

### 早期Unix内核

传统的Unix内核的"全封闭"的。如果要往内核中添加一个设备（或是添加一种服务），早期的做法是编写这个设备的驱动程序，并变动内核源代码程序中的某些数据结构（设备表），再重新编译整个内核，并重新引导整个系统。这个做法虽然更能保证安全性，但是过程过于僵化。

### Linux内核

Linux既允许把驱动程序在编译时静态的链接在内核中，也允许的在运行时安装，称为"模块"，还允许在运行在运行状态下当需要用到某个模块时由系统自动安装。这样保证模块仍然在内核中运行，又更加灵活。

### Linux内核文件结构

#### COPYING

有关FSF公共许可证制度GPL的具体说明

#### README

Linux内核安装和使用的简要说明

#### Makefile

重构Linux内核可执行代码的make文件

#### Documentation

Linux内核的相关文档

#### arch

arch是architecture的缩写，内核中与具体CPU和系统结构相关的代码分别放在这里，相关的.h文件则分别放在inlcude/asm目录下。

> 在每个CPU的子目录中，又进一步分解为boot，mm，kernel等子目录，分别包含与系统引导，内存管理，系统调用的进入和返回，中断处理以及其他内核中依赖于CPU和系统结构的底层代码。

#### drivers

设备驱动程序，包括各种块设备和字符设备的驱动程序。

#### fs

文件系统，每个子目录分别对应一个特定的文件系统，还有一些共同的源程序则用于"虚拟文件系统"vfs。

#### include

包含了所有的.h文件。在include中也是为各种CPU都专设一个子目录，而通用的子目录asm则根据系统的配置而"符号链接"到具体CPU的专用子目录。还有通用子目录linux，net等。

#### init

Linux 内核的main()及其初始化过程，包括: main.c, version.c等文件。

#### ipc

Linux 内核的进程间通信，包括: util.c, sem.c, shm.c, msg.c等文件。

#### kernel

进程管理和调度，包括: sched.c, fork.c, exit.c, signal.c, sys.c, time.c, resource.h, dma.c softirq.c, itimer.c等文件。

#### lib

通用的工具子程序，比如出错信息的处理等等。

#### mm

内存管理，即虚拟内存管理，包括：swap.c, swapfile.c, page_io.c, page_alloc.c, swap_state.c, vmscan.c, kmall.c, vmalloc.c, memory.c, mmap,c等文件。

#### net

包含了各种不同网卡和网络规程的驱动程序。

#### script

用于系统配置的命令文件。

### 内核版本发行规则

版本号的格式为"x.yy.zz"。其中x介于0~9之间，y和z介于0~99之间。一些版本号会见到pNN的字样，NN是介于0~20之间的数字，它代表对某一版本的内核修改的次数，如0.99p15。

x代表在内核在设计上或实现上的重大转变，yy代表版本的变迁，偶数代表稳定版，奇数代表开发版。zz代表内核只是增加了内容。

#### Undocumented DOS

#### Undocumented Windows

## Intel X86 CPU系列的寻址方式

###	 位数，数据总线和地址总线 

CPU中位数是处理器中算术逻辑单元（ALU）的宽度。

系统总线中数据总线，通常与ALU的宽度相同（但有例外）。

地址总线对于程序员来讲，最自然的就是和数据总线一致，但是8位只能寻址256个不同的地址单元。Intel8086采用16位CPU，采用1M的寻址空间。

### 实地址模式

Intel在8086CPU中设置4个段寄存器: CS, DS, SS和ES，分别用于可以执行代码即指令、数据、堆栈和其他。

每个段寄存器都是16位的，对应于地址总线中的高16位。每条访问内存指令中的内部地址都是16位，但是在送上地址总线之前都在CPU内部自动与某个段寄存器中的内容相加，形成了20位的实际地址。

段寄存器中的内容对应于20地址总线中的高16位，所以在相加时实际上用内部地址中的高12位与段寄存器中的16位相加，而内部地址中的低4位保持不变。

对于每一个由段寄存器的内容确定的基地址，一个进程总是能够访问从此开始的64K字节的连续地址空间，同时，可以用来改成段寄存器内容的指令也不是特权指令。缺乏对内存访问的限制。

### 保护模式

Intel80386是32位CPU，ALU数据总线是32位，同时地址总线宽度达到了32位时，寻址能力达到了4G。为了达到兼容上代产品，80386必须维持段寄存器，还必须支持实地址模式，又能支持保护地址模式。

Intel采用在段寄存器上构建保护模式的构思，保留原有的16位段寄存器，添加了两个新寄存器FS和GS。Intel基本设计思路是：在保护地址模式下改变段寄存器功能，使其从一个单纯的基地址变成指向一个数据结构的指针：

（1）根据指令的性质来确定应该使用哪个段寄存器，例如转移指令中的地址在代码段，而取数指令中的地址在数据段。

（2）根据段寄存器的内容，找到相应的地址段描述结构。

（3）从地址段描述结构中得到基地址。

（4）将指令中发出的地址作为位移，与段描述结构中规定的段长度相比，查看是否越界。

（5）根据指令的性质和段描述符中的访问权限来确定是否越权。

（6）将指令中发出的地址作为位移，与基地相加而得出实际的物理地址。

### 80386段式聂存管理机制

80386CPU中增设了两个寄存器：一个是全局性的段描述表寄存器GDTR（global descriptor table register），另一个是局部性的段买哦书表寄存器LDTR（local descriptor table register）分别可以用来指向存储在内存中的一个段描述结构数组。由于这两个寄存器是新增的，不存在向前兼容性问题，访问这两个寄存器的专用指令便设计成特权指令。

段寄存器的高13位用作访问段描述表中具体描述结构的下体（index）。


////////////////////////////////////////////////////////////

图：段寄存器定义

////////////////////////////////////////////////////////////

GDTR或LDTR中的段描述表指针和段寄存器中给出的下标结合在一起，才决定了具体的段描述表项在内存中的位置。将段寄存器内容的低3位屏蔽掉以后与GDTR或LDTR中的基地址相加得到描述项表的起始地址。

每个段描述表项的大小是8个字节，每个描述表项含有段的基地址和段的大小，在加上其他的一些信息。


////////////////////////////////////////////////////////////

图：8字节段描述表项的定义

////////////////////////////////////////////////////////////

结构中的B31~B24和B23~B16分别为基地址的bit16~bit23和bit24~bit23和bit24~bit31。而L19~L16和L15~L0则为段长度（limit）的bit0~bit15和bit16~bit19。


////////////////////////////////////////////////////////////

图：段描述表项TYPE字节的定义

////////////////////////////////////////////////////////////


伪代码说明整个段描述结构

```
typedef struct {
	unsigned int base24_31 : 8;	/* 基地址的最高8位 */
	unsigned int g : 1;			/* granularity, 表段的长度单位， 0表示字节， 1表示4KB */	
	unsigned int d_b : 1;		/* default operation size 存取方式，0=16位，1=32位 */
	unsigned int unused : 1;	/* 固定设置成0 */
	unsigned int avl : 1; 		/* available, 可提供系统软件使用 */
	unsigned int seg_limit 16_19 : 4; /* 段长度的最高4位 */
	unsigned int p : 1;			/* segmetn present, 为0时表示该段的内容不在内存中 */
	unsigned int dpl : 2;		/* Descriptor privilege level, 访问本段所需要的权限 */
	unsigned int s : 1;			/* 描述项类型 1 表示系统， 0 表示代码或数据 */
	unsigned int type : 4;		/* 段的类型，与上面的S标志位一起使用 */ 
	unsigned int base_0_23 : 24 /* 基地址的低24位 */
	unsigned int seg_limit_0_15 : 16	/* 段长度的低16位 */
}
```

每当一个寄存器的内容改变时（通过MOV，POP等指令或发生中断等事件），CPU就把由这段寄存器的新内容所聚丁的段描述项装入CPU内部的一个**shadow**描述项。这样，CPU中有几个段寄存器就有几个shadow描述项，也可以看做是对寄存器的扩充。扩充后的段寄存器分成了两个部分，一部分是可见（对程序）,还与原先的段寄存器一样，另一部分是不可见的，用来存放影子描述项的空间，专供CPU使用。

在80386的段式内存管理的基础上，如果把每个段寄存器都指向同一个描述项，而在该描述项中则将基地址设成0，并将段长度设成最大，这样形成一个从0开始覆盖整个32位地址空间的一个整段。由于基地址为0，此时的物理地址与逻辑地址相同，CPU放到地址总线上去的地址就是在指令中给出的地址。这样的地址有别于由"段寄存器/位移量"构成的"层次式"地址，所以Intel称其为"平面"(Flat)地址。而这个只是段式内存管理的一种特例。

利用80386对段式内存管理的硬件支持，可以实现段式虚存管理。当一个段寄存器的内容改变时，CPU要根据新的段寄存器内容以及GDTR或LDTR的内容找到相应段描述项并将其装入CPU中。在此过程中，CPU会检查该描述表中的P标志位（表示"present"），如果p标志位为0，就表示该描述项所指向的那一段内容不在内存中（也就是说，在磁盘上的某个位置），此时CPU会产生一次异常（exception，类似于中断），而相应的服务程序便可以从磁盘交换区将这个一段的内容读入内存中的某个地方，并根据设置描述项中的基地址，再将P标志位设置成1.相应地，内存中暂定不用的存储段则可以写入磁盘，并将其描述项中P标志改成0。

对段式内存管理的支持只是i386保护模式一个组成部分。80386不是简单的划分了系统状态和用户状态，而是划分4个特权级别，其中0级为最高，3级为最低。

16位的段寄存器中的高13位用作下标来访问段描述表，低3位结构。

```c
typedef struct{
	unsigned short seg_idex : 13; 
	unsigned short ti : 1;
	unsigned short rpl : 2
}
```

当段寄存器CS中的ti位为1时，表示要使用全局段描述表，为0时，则表示要使用的局部段描述表而rpl则表示所要求的权限。当改变一个段寄存器的内容时，CPU会加以检查，以确保该段程序的当前执行权限和段寄存器所指定要求的权限均不低于所要访问的那一段内存权限dpl。

除了全局段描述表指针GDTR和局部段描述表指针LDTR两个寄存器外，i386CPU中还有中断向量表指针寄存器IDTR，与进程有关的寄存器TR以及描述以及描述任务状态的"任务状态段"TSS等。


## i386的页式内存管理机制

内存管理有两种，一种是段式管理，另一种是页式管理。80286实现了段式内存管理，从80386开始实现了页式内存管理。





